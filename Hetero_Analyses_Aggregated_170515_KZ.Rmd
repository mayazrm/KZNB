---
title: "Aggregated Code and Analyses for Heterogeneity Paper"
output: html_notebook
---

- KZ: look into what psych science requires with the submission
- svg format for graphs?
- 


# Study 1: KZ & MR Valence Dataset

## Loading Data and Packages
```{r KZMR Loading Data and Packages}

# For working draft of script, see file Random_Project_170311_Study1


setwd("~/KZNB")
rnd <- read.csv("randomproject_data_aggregated_161021.csv")
rndt <- rnd

library(lme4)
library(ggplot2)
library(lmerTest)
theme_set(theme_bw(base_size = 14))
library(car)
#For dotplots
library(Rcmdr)


# so that one unit (-.5, .5) = duration of study
rndt$trial40 <- (rndt$trials.thisN + 1) 
rndt$trial40c <- (rndt$trial40 - 20)/40

rndt$rt <- rndt$response.rt
#rndt$logrt <- log(rndt$response.rt)

rndt$id <- rndt$ID

rndt$valenceE <-recode(rndt$valence, as.factor.result=F, '"negative" = -0.5; "positive" = 0.5')

rndt$rtms <- rndt$rt*1000
rndt$logrt <- log(rndt$rtms)

```



## Data Subsetting and Analyses
```{r}
rndtb2 <- subset(rndt, response.keys == "up") # subset to only select traits endorsed as self-relevant
rndtb <- subset(rndtb2, rt >= .01 & rt < 1.45) #90th percentile or below
rndtb2$rt.z <- scale(rndtb2$rt)
rndtz <- subset(rndtb2,  rt.z < 3) #within 3 SD of the mean RT
rndtzz<-rndtz[!(rndtz$id %in% c(250, 257, 272)), ]

# with Random Intercepts only
mle3aaa_intonly <- (lmer(logrt ~ valenceE + (1 | id),  data=rndtzz))
summary(mle3aaa_intonly)


# with Random Slopes
mle3aaa <- (lmer(logrt ~ valenceE + (1 + valenceE| id),  data=rndtzz))
summary(mle3aaa)

```
## Dotplot 
```{r Dotplot}
ranef.mle3aaa <- summary(mle3aaa)$coeff["valenceE", "Estimate"] + ranef(mle3aaa)$id[,2] #ValencE column

ranef.mle3aaa.quant <- quantile(ranef.mle3aaa, probs=c(.025, .975))

pdf("Study1_KZMRData_dotplot.pdf")
stripchart(ranef.mle3aaa, pch=21, bg="red", cex=3.5, lwd=2,
           xlim=c(-.45, .1), xlab="Trait Valence Effect (logRT units)", cex.axis=1.5, cex.lab=1.5)
abline(v=c(ranef.mle3aaa.quant[1], summary(mle3aaa)$coeff["valenceE", "Estimate"], ranef.mle3aaa.quant[2]), col = c("red", "black", "red"),
       lwd = 3)
dev.off()

```


## Study 1 Panel Plots
```{r}

#Put the EBLUPs of the random effects into a separate dataset
cfs1 <- (ranef(mle3aaa))
cfs2 <- as.data.frame(cbind(cfs1$id[,1], cfs1$id[,2]))
cfs2$id <- rbind(201,202,204,205,206,207,208,209,210,212,219,220,221,222,223,224,226,228,229,232,
           234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,251,252,254,255,
           256,262,263,264,265,266,267,268,269,270,271,273,274,301,302,303,304,305,306) #Add in id numbers

names(cfs2) <- make.names(names(cfs2))
names(cfs2)[c(2,1)] <- c("ebslope","ebintercept") 


# adding in fixed effects
cfs2$intercept<- (summary(mle3aaa)$coeff["(Intercept)", "Estimate"] + cfs2$ebintercept) 
cfs2$slope<- (summary(mle3aaa)$coeff["valenceE", "Estimate"] + cfs2$ebslope)

#Merge upper-level variables with the process data frame
rndtzm <-merge(rndtzz, cfs2, all=TRUE, by="id")

#Create predicted values based on within-subject causal model
rndtzm$pred<-(rndtzm$intercept + rndtzm$slope*rndtzm$valenceE)

#To create graphs based on observed data only: Sort the dataset by slope, ID, and valence
ordrndtzm<-rndtzm[order(rndtzm$slope, rndtzm$id, rndtzm$valenceE),]

#Sort the upper-level data frame by slope and ID
ordcfs2<-cfs2[order(cfs2$slope, cfs2$id),]


# panel plot sorted by random slope
pdf(file="study1_kzmrdata_panelplotbyranef.pdf", width=14, height=10)
par(mfrow=c(6,10))
for (i in c(208,222,255,248,267,266,263,212,303,205,220,304,273,226,209,221,246,245,306,254,
            269,234,252,302,256,238,301,202,265,243,241,232,204,305,223,251,268,224,210,264,
            274,236,237,249,235,271,262,228,229,240,201,219,206,244,270,239,207,247)) {  
  plot(rndtzm$valenceE[rndtzm$id==i], rndtzm$logrt[rndtzm$id==i], 
       ylab="logrt", xlab="Valence", type="p", pch=1, xlim=c(-0.8, 0.8), ylim=c(6,8),
       main=paste(round(cfs2$slope[cfs2$id==i], digits=3)))
  lines(ordrndtzm$valenceE[ordrndtzm$id==i], ordrndtzm$pred[ordrndtzm$id==i]) 
}
mtext("Log RT by Valence, ID's Sorted by Size of Random Slope", side=3, outer=TRUE, line=-1.2)
dev.off()

# as svg
svg(file="study1_kzmrdata_panelplotbyranef.svg", width=14, height=10)
par(mfrow=c(6,10))
for (i in c(208,222,255,248,267,266,263,212,303,205,220,304,273,226,209,221,246,245,306,254,
            269,234,252,302,256,238,301,202,265,243,241,232,204,305,223,251,268,224,210,264,
            274,236,237,249,235,271,262,228,229,240,201,219,206,244,270,239,207,247)) {  
  plot(rndtzm$valenceE[rndtzm$id==i], rndtzm$logrt[rndtzm$id==i], 
       ylab="logrt", xlab="Valence", type="p", pch=1, xlim=c(-0.8, 0.8), ylim=c(6,8),
       main=paste(round(cfs2$slope[cfs2$id==i], digits=3)))
  lines(ordrndtzm$valenceE[ordrndtzm$id==i], ordrndtzm$pred[ordrndtzm$id==i]) 
}
mtext("Log RT by Valence, ID's Sorted by Size of Random Slope", side=3, outer=TRUE, line=-1.2)
dev.off()


```


# Study 2: Ran Face Dataset
```{r Analyses for Upright v. Upside-Down only}

# For working draft of script, see file RanData_Heterogeneity_170215

ranfacefo1 <- read.csv("ranfacefo1.csv") # contains Upright and Upside-Down Conditions Only


#Run Upright-Upsidedown Model

ranfacem1 <- lmer(logRT ~ fo1 + (fo1 | Participant), data = ranfacefo1)
summary(ranfacem1)
# confint(ranfacem1)

#Run Model with Random Intercept Only
ranfacem1_intonly <- lmer(logRT ~ fo1 + (1 | Participant), data = ranfacefo1)
summary(ranfacem1_intonly)
anova(ranfacem1, ranfacem1_intonly)

```

## Plots
```{r}
#Get Ranefs for f01
#Add ID Column
#Order by Ranef Size
ranfacem1.ranef<-ranef(ranfacem1)$Participant
ranfacem1.ranef$Participant <- as.numeric(row.names(ranfacem1.ranef))
ranfacem1.ranef$fo1 <- ranfacem1.ranef$fo1 -0.20156
ordranfacem1.ranef <- ranfacem1.ranef[order(ranfacem1.ranef$fo1), ]

#Add Predicted Values to ranface
ranfacefo1$pred <- fitted(ranfacem1)

#Order ranface by Participant, Face-orientation, predicted value
ordranfacefo1 <- ranfacefo1[order(ranfacefo1$Participant, 
                            ranfacefo1$Face_orientation, ranfacefo1$pred), ]

#Dotplot

windows()
pdf("ranface-ranef-log-dotplot.pdf", width = 8, height = 3)
stripchart(ranfacem1.ranef$fo1, pch=1, bg="skyblue", cex=3, lwd=2,
           xlim=c(-0.45, .1), xlab="Heterogeneity in Face Orientation Effect (logRT units)", cex.axis=1.5, cex.lab=1.5)
abline(v=c(-0.36, -0.21, -.01), col = c("red", "black", "red"),
       lwd = 3)
dev.off()

#Panel plots ordered by size of fo1 random effect

windows(width = 10, height = 8)
pdf("ranface-fitted-panels-log.pdf", width = 10, height = 8)
par(mfrow=c(3,7))
for (i in ordranfacem1.ranef$Participant) {
  plot(jitter(ordranfacefo1$fo1[ordranfacefo1$Participant==i], .25), 
       ordranfacefo1$logRT[ordranfacefo1$Participant==i],
       ylab="logRT", xlab="Upright",
       type="p", pch="O", col="blue", ylim=c(-.7, 2.3), xlim=c(0, 1),
       main=paste(round(ordranfacem1.ranef$fo1[ordranfacem1.ranef$Participant==i], digits=2), sep = " "))
  lines(ordranfacefo1$fo1[ordranfacefo1$Participant==i], 
  ordranfacefo1$pred[ordranfacefo1$Participant==i], lwd=5, col="red")
}
dev.off()

```


# Study 2: Ran Math Priming (Exp 6) Dataset
```{r}

# For working draft of script, see file RanData_Heterogeneity_170215

ran6a <- read.csv("ran_exp6_all_data_long.csv")
ran6 <- subset(ran6a, exclude_from_analysis == "FALSE" & operand == "S" & rt != "NA")

ran6$presentation_time_f <- as.factor(ran6$presentation_time)

ran6$congr <- ifelse(ran6$congruent == "no", -.5, .5)
ran6$ptimer <- ifelse(ran6$presentation_time == "1700", -.5, .5)
ran6$logrt <- log(ran6$rt)
```

## Analyses using logRT
```{r}
## random intercept only
ran6mod1 <- lmer(logrt ~ congr*ptimer + (1 | subject), data = ran6)
summary(ran6mod1)
confint(ran6mod1, oldNames = FALSE)

## random slopes
ran6mod2 <- lmer(logrt ~ congr*ptimer + (1 + congr | subject), data = ran6)
summary(ran6mod2)

anova(ran6mod1, ran6mod2)
```

## Plots
```{r}
#Get Ranefs for congr
#Add ID Column
#Order by Ranef Size
ran6mod2.ranef<-ranef(ran6mod2)$subject
ran6mod2.ranef$subject <- as.numeric(row.names(ran6mod2.ranef))
ran6mod2.ranef$congr <- ran6mod2.ranef$congr -0.022654
ordran6mod2.ranef <- ran6mod2.ranef[order(ran6mod2.ranef$congr), ]

#Add Predicted Values to ranface
ran6$pred <- predict(ran6mod2)

#Order ranface by Participant, Face-orientation, predicted value
ordran6 <- ran6[order(ran6$subject, 
                            ran6$congr, ran6$pred), ]


#Panel plots ordered by size of random effect
windows()
pdf("ran6-log-fitted-panels.pdf", width = 10, height = 8)
par(mfrow=c(3,7))
for (i in ordran6mod2.ranef$subject) {
  plot(jitter(ordran6$congr[ordran6$subject==i], .35), 
       jitter(ordran6$logrt[ordran6$subject==i], .15),
       ylab="RT", xlab="Congruence",
       type="p", pch=1, col="blue", ylim=c(6.0, 7.0), xlim=c(-0.55, .55),
       main=paste(round(ordran6mod2.ranef$congr[ordran6mod2.ranef$subject==i], digits=2), sep = " "))
  lines(ordran6$congr[ordran6$subject==i], 
  ordran6$pred[ordran6$subject==i], lwd=5, col="red")
}
dev.off()


# Dot Plot
quantile(ran6mod2.ranef$congr, probs=c(.025, .5, .975))
pdf("random_ran6_log_dotplot.pdf", width = 8, height = 3.0) 
stripchart(ran6mod2.ranef$congr, pch=1, bg="skyblue", cex=3, lwd=2,
           xlim=c(-.027, -0), xlab="Heterogeneity in Congruency Effect (log RT units)", cex.axis=1.5, cex.lab=1.5)
abline(v=c(-0.02612950, -0.02274863, -0.01965485), col = c("red", "black", "red"),
       lwd = 3)
dev.off()

anova(ran6mod1, ran6mod2)

```



# Explaining Causal Heterogeneity - Reg Focus Analyses with KZ/MR Dataset

## Reading in Data with Individual Difference Variables
```{r}

# For working draft of script, see file Random_Project_170223_Study1_RegFocus


rndid <- read.csv("Heterogeneity_Project_Questionnaires.csv")
rndid$ID <- rndid$subject

# Mean centering function
center <- function(x) {
  scale(x, center=T, scale=F)
}

library(psych)

# Regulatory Focus
rndid$rfq1r <- 6-rndid$rfq1
rndid$rfq9r <- 6-rndid$rfq9
rndid$rfq11r <- 6-rndid$rfq11
rndid$rfq2r <- 6-rndid$rfq2
rndid$rfq4r <- 6-rndid$rfq4
rndid$rfq6r <- 6-rndid$rfq6
rndid$rfq8r <- 6-rndid$rfq8

rndid$prom.matrix <- cbind(rndid$rfq1r, rndid$rfq3, rndid$rndid$rfq7, rndid$rfq9r, rndid$rfq10, rndid$rfq11r)
psych::alpha(rndid$prom.matrix) # alpha = .45
rndid$prom.v <- as.vector(rowMeans(rndid$prom.matrix, na.rm=T))
rndid$prom.c <- scale(rndid$prom.v, center=T, scale=F)

rndid$prev.matrix <- cbind(rndid$rfq2r, rndid$rfq4r, rndid$rfq5, rndid$rfq6r, rndid$rfq8r)
psych::alpha(rndid$prev.matrix) # alpha = .79
rndid$prev.v <- as.vector(rowMeans(rndid$prev.matrix, na.rm=T))
rndid$prev.c <- scale(rndid$prev.v, center=T, scale=F)



```


## Merging RT data with reg focus variables & Moderation Analysis
```{r}

datamerge <- merge(rndid, rndtzz, by = "ID")

modindiv1 <- lmer(logrt ~ valenceE*prom.c*prev.c + (1 + valenceE| id),  data=datamerge)
summary(modindiv1)
# significant interaction of valence and promotion
# marginally significant interaction of valence and prevention

```

## Valence X Promotion and Valence X Prevention Figures
```{r}
#### Promotion x Valence Figure:

# make valenceE into a factor so we can color code datapoints
datamerge$valenceE_fac <- ifelse(datamerge$valenceE==.5, "pos", "neg")
datamerge$valenceE_fac <- as.factor(datamerge$valenceE_fac)


# define new dataframe with all variables set at desired values except for promotion. Valence set to positive
prompos <- data.frame(prom.c = seq(min(datamerge$prom.c, na.rm=T), max(datamerge$prom.c, na.rm=T), .05),
                     prev.c = 0, valenceE = .5)
                       
 
# set up design matrix
mmprompos<-model.matrix(~valenceE*prom.c*prev.c, prompos)

# obtain fitted values using new dataframe and model predictions
prompos$rtpos <- predict(modindiv1, prompos, re.form=NA)

# multiply the design matrix by the covariance matrix from the model to get 95% CIs
pvarprompos<- diag(mmprompos %*% tcrossprod(vcov(modindiv1),mmprompos))
prompos$rtlo <- prompos$rtpos-1.96*sqrt(pvarprompos)
prompos$rthi <- prompos$rtpos+ 1.96*sqrt(pvarprompos)



# repeat steps for when valence is negative
promneg <- data.frame(prom.c = seq(min(datamerge$prom.c, na.rm=T), max(datamerge$prom.c, na.rm=T), .05), prev.c = 0, valenceE = -.5)
                       
mmpromneg<-model.matrix(~valenceE*prom.c*prev.c, promneg)

promneg$rtpos <- predict(modindiv1, promneg, re.form=NA)
pvarpromneg<- diag(mmpromneg %*% tcrossprod(vcov(modindiv1),mmpromneg))
promneg$rtlo <- promneg$rtpos-1.96*sqrt(pvarpromneg)
promneg$rthi <- promneg$rtpos+1.96*sqrt(pvarpromneg)


# create figure
pdf("valenceXprom_figure.pdf", width = 10, height = 10) 
plot(jitter(datamerge$prom.c), jitter(datamerge$logrt), pch = c("neg" = 1, "pos" = 19)[datamerge$valenceE_fac], frame = F, ylim=c(5.9, 7.7), col = c("neg" = "gray30", "pos" = "darkgreen")[datamerge$valenceE_fac], cex  = .5, cex.lab = 1.5, cex.axis = 1.3,
     xlim=c(-2.15, 1.1), xlab="Promotion Focus (mean centered)", 
     ylab="Log RT")
polygon(c(prompos$prom.c,rev(prompos$prom.c)),
        c(prompos$rtlo,rev(prompos$rthi)),
        col=rgb(.1, 0.8, 0.1, 0.1),
        border = NA)
polygon(c(promneg$prom.c,rev(promneg$prom.c)),
        c(promneg$rtlo,rev(promneg$rthi)),
        col=rgb(.1, 0.1, 0.1, 0.1),
        border = NA)
lines(prompos$prom.c, prompos$rtpos, lty=1, lwd=4, col = "darkgreen")
lines(prompos$prom.c, prompos$rtlo, lty='solid', col = "darkgreen", lwd = .5)
lines(prompos$prom.c, prompos$rthi, lty='solid', col = "darkgreen", lwd = .5)
lines(promneg$prom.c, promneg$rtpos, lty='longdash', lwd=4, col = "gray30")
lines(promneg$prom.c, promneg$rtlo, lty='longdash', col = "gray30", lwd = .5)
lines(promneg$prom.c, promneg$rthi, lty='longdash', col = "gray30", lwd = .5)
legend(-2,6.15, c("Negatively Valenced Words", "Positively Valenced Words"),
       lty=c('longdash','solid'), # gives the legend appropriate symbols (lines)
       lwd=c(2,2),col=c('gray30','darkgreen'),
       pch = c(1, 19), cex = 1.3, pt.cex = 1)
dev.off()



## Prevention x Valence Figure:

prevpos <- data.frame(prev.c = seq(min(datamerge$prev.c, na.rm=T), max(datamerge$prev.c, na.rm=T), .05),
                     prom.c = 0,  valenceE = .5)
                       
  
mmprevpos<-model.matrix(~valenceE*prom.c*prev.c, prevpos)

prevpos$rtpos <- predict(modindiv1, prevpos, re.form=NA)
pvarprevpos<- diag(mmprevpos %*% tcrossprod(vcov(modindiv1),mmprevpos))
prevpos$rtlo <- prevpos$rtpos-1.96*sqrt(pvarprevpos)
prevpos$rthi <- prevpos$rtpos+1.96*sqrt(pvarprevpos)


prevneg <- data.frame(prev.c = seq(min(datamerge$prev.c, na.rm=T), max(datamerge$prev.c, na.rm=T), .05),
                     prom.c = 0,  valenceE = -.5)
                       
  
mmprevneg<-model.matrix(~valenceE*prom.c*prev.c, prevneg)

prevneg$rtpos <- predict(modindiv1, prevneg, re.form=NA)
pvarprevneg<- diag(mmprevneg %*% tcrossprod(vcov(modindiv1),mmprevneg))
prevneg$rtlo <- prevneg$rtpos-1.96*sqrt(pvarprevneg)
prevneg$rthi <- prevneg$rtpos+1.96*sqrt(pvarprevneg)


pdf("valenceXprev_figure.pdf", width = 10, height = 10) 
plot(jitter(datamerge$prev.c), jitter(datamerge$logrt), pch = c("neg" = 1, "pos" = 19)[datamerge$valenceE_fac],
     frame = F, ylim=c(5.9, 7.7), col = c("neg" = "gray30", "pos" = "darkred")[datamerge$valenceE_fac], cex  = .5, cex.lab = 1.5, cex.axis = 1.3,
     xlim=c(-2.15, 1.1), xlab="Prevention Focus (mean centered)", 
     ylab="Log RT")
polygon(c(prevpos$prev.c,rev(prevpos$prev.c)),
        c(prevpos$rtlo,rev(prevpos$rthi)),
        col=rgb(.8, 0.1, 0.1, 0.1),
        border = NA)
polygon(c(prevneg$prev.c,rev(prevneg$prev.c)),
        c(prevneg$rtlo,rev(prevneg$rthi)),
        col=rgb(.1, 0.1, 0.1, 0.1),
        border = NA)
lines(prevpos$prev.c, prevpos$rtpos, lty=1, lwd=4, col = "darkred")
lines(prevpos$prev.c, prevpos$rtlo, lty='solid', col = "darkred", lwd = .5)
lines(prevpos$prev.c, prevpos$rthi, lty='solid', col = "darkred", lwd = .5)
lines(prevneg$prev.c, prevneg$rtpos, lty='longdash', lwd=4, col = "gray30")
lines(prevneg$prev.c, prevneg$rtlo, lty='longdash', col = "gray30", lwd = .5)
lines(prevneg$prev.c, prevneg$rthi, lty='longdash', col = "gray30", lwd = .5)
legend(-2,6.15, c("Negatively Valenced Words", "Positively Valenced Words"),
       lty=c('longdash','solid'), # gives the legend appropriate symbols (lines)
       lwd=c(2,2),col=c('gray30','darkred'),
       pch = c(1, 19), cex = 1.3, pt.cex = 1)
dev.off()


```

# Explaining Causal Heterogeneity - Reg Focus Analyses with Yuka & Abby Dataset
```{r}

yuka <- read.csv("RTexpttwo.csv")

# changing effect coding to +0.5/-0.5 to be consistent with KZMR data
yuka$valenceE <- ifelse(yuka$trait_vale== 1, .5, -.5)


# Random intercept only
logRTmodel_intonly <- lmer(rt_log ~ valenceE + (1 | subj), data = yuka)
summary(logRTmodel_intonly)


logRTmodel <- lmer(rt_log ~ valenceE + (1 + valenceE | subj), data = yuka)
summary(logRTmodel)

```
## Dotplot 
```{r}
ranef.logRTmodel <- summary(logRTmodel)$coeff["valenceE", "Estimate"] + ranef(logRTmodel)$subj[,2] #ValencE column

ranef.logRTmodel.quant <- quantile(ranef.logRTmodel, probs=c(.025, .975))

pdf("YukaData_dotplot.pdf")
stripchart(ranef.logRTmodel, pch=21, bg="red", cex=3.5, lwd=2,
           xlim=c(-.45, .12), xlab="Trait Valence Effect (logRT units)", cex.axis=1.5, cex.lab=1.5)
abline(v=c(ranef.logRTmodel.quant[1], summary(logRTmodel)$coeff["valenceE", "Estimate"], ranef.logRTmodel.quant[2]), col = c("red", "black", "red"),
       lwd = 3)
dev.off()

```

## Dotplots for T1 and T2 from Yuka Dataset
```{r}

# Load Data & Variables into global environment

total <- read.csv("total_datafortimeplots_yuka.csv")

windows()
par(mfrow=c(2,1)) 
stripchart(total$posminusneg1, pch=21, bg="skyblue", cex=3.5, lwd=2,
           xlim=c(-.60, .22), xlab="Trait Valence Effect: Time 1", cex.axis=1.5, cex.lab=1.5)
#abline(v=c(-.146), lwd=5, col="skyblue")
#mtext("-0.25", 1, line=2.7, adj=.48, cex=2)
#mtext("Average", 3, line=.5, adj=.48, cex=2)

stripchart(total$posminusneg2, pch=21, bg="skyblue", cex=3.5, lwd=2, xlim=c(-.60, .22),
           xlab="Trait Valence Effect: Time 2", cex.axis=1.5, cex.lab=1.5)
#abline(v=c(-.254), lwd=5, col="skyblue")
#mtext("-0.25", 1, line=2.7, adj=.48, cex=2)
#mtext("Average", 3, line=.5, adj=.48, cex=2)


### Correlation with Ellipse

library(ellipse)

muII=c(-0.14545, -0.25251)
sigmaII=matrix(c(0.20967^2, 0.02882221, 0.02882221, 0.20832^2), nrow=2, byrow=TRUE)

windows()
par(mfrow=c(1,1)) 
plot(total$posminusneg1, total$posminusneg2, pch=21, bg="skyblue",
     cex=3.5, lwd=2, xlim=c(-.60, .22), ylim=c(-.60, .22),
     xlab="Trait Valence Effect: Time 1", ylab="Trait Valence Effect: Time 2",
     cex.lab=1.5, cex.axis=1.5)
par(new=T)
plot(ellipse(sigmaII, centre = muII, level=0.95, npoints=1000), type="l", lwd=4,
     xlim=c(-.60, .22), ylim=c(-.60, .22), xlab="", ylab="",
     cex.lab=1.5, cex.axis=1.5)


```

